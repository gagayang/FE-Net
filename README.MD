# 前端简单基础网络知识

## OSI基础网络模型
**开放式系统互联**

一般可以认为这个是网络模型的参考模式。7层模型

1. 物理层
2. 数据链路层
3. 网络层
4. 传输层
5. 会话层
6. 表示层
7. 应用层

## 五层模型
1. 物理层
2. 数据链路层
3. 网络层
4. 传输层
5. 应用层

## TCP/IP四层模型

1. 数据链路层
2. 网络层
3. 传输层
4. 应用层


![](/Users/gaoyang/learn/前端目前知识图谱/FE-Net/images/20170822224933262.png)

## 三次握手
1. TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；
2. TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
3. TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
4. TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。
5. 当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。

![](/Users/gaoyang/learn/前端目前知识图谱/FE-Net/images/20170607205709367.gif)



## 四次挥手告别
1. 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2. 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。
![](/Users/gaoyang/learn/前端目前知识图谱/FE-Net/images/20170607205756255.gif)


## http协议
HTTP，全称超文本传输协议（HTTP，HyperText Transfer Protocol)，是一个客户端和服务器端请求和应答的标准（TCP），互联网上应用最为广泛的一种网络协议。

HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据

1. http 1.0
2. http 1.1
3. https
4. http 2.0

协议|版本|是否链接复用|是否加密|推送|默认端口
---|:--:|--:|--:|--:|--:|--:|--:
http|1.0|否|否|否|80|
http|1.1|是|否|否|80|
https||是|是|否|443|
http|2.0|是|是|是|80

### http 1.0
在1.0的时候，想的比较简单就是打开一个请求，得到回复之后就关闭。
但是这个很多时候不太符合。比如我们打开一个网页里面很多资源都是来自src标签。这样就要关闭然后再打开链接。造成链接的大量的开启关闭。性能就不是很好。

### http 1.1
这个是目前我们应该是使用和接触最多的http版本。这里就只吃了链接复用。

在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。

在http1.1，request和reponse头中都有可能出现一个connection的头，此header的含义是当client和server通信时对于长链接如何进行处理。

### https

在上面的http 1.1其实解决了很多的问题。但是有一个问题还是没有解决。http在传输的过程中其实用的是明文。这样就很容易被偷窥。

而且服务器的认证也是个问题。

后来为了解决这个问题就出现了证书机制，具体来说就是 我公司会通过非对称加密的形式产生一对密钥。公钥就和公司的其他信息一起去第三方公司去申请证书。私钥就在服务器配置。

如果有人访问就会按照以下规则进行

1. 浏览器将自己支持的一套加密规则发送给网站。
2. 网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。
3. 获得网站证书之后浏览器要做以下工作：
	
	a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。
	
	b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。
	
	c) 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。
4. 网站接收浏览器发来的数据之后要做以下的操作：

	a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。

	b) 使用密码加密一段握手消息，发送给浏览器。
5. 浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。

这里要注意证书信息会保存到注册表中（我也不知道是不是真的。）

## http 方法

1. HEAD 请求获取由Request-URI所标识的资源的响应消息报头
2. GET 
3. POST
4. PUT
5. DELETE
6. TRACE
7. OPTIONS

这里要说一下options 这个方法以前我也经常见过。但是没太注意就是知道它是一个预检测方法。但是为什么要用它。怎么避免它我还真没太注意。

其实这个是使用cros 跨域的时候产生的。

在使用cros 跨域的时候请求会被分为两种。

1. 简单请求
2. 非简单请求

简单请求的时候就不需要预检测。直接发送真正请求。
非简单请求就需要进行预检测。得到服务器允许才可以发送真正请求

> 简单请求

1. 请求方法为 head post get 这三种其中一种 	
2. 请求的header 中只能包括下面几项
	*  Accept
	*  Accept-Language
	*  Content-Language
	*  Content-Type 只能为以下几种
		*  application/x-www-form-urlencoded
		*  multipart/form-data
		*  text/plain
	* Last-Event-Id
	
[参考资料](http://www.ruanyifeng.com/blog/2016/04/cors.html)

## request Header

GET / HTTP/1.1

Host:xxx.xxxx.com

User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.0.10) Gecko/2016042316 Firefox/3.0.10

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language: en-us,en;q=0.5

Accept-Encoding: gzip,deflate

Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7

Keep-Alive: 300

Connection: keep-alive

If-Modified-Since: Mon, 25 May 2016 03:19:18 GMT

## response header

HTTP/1.1 200 OK

Cache-Control: private, max-age=30

Content-Type: text/html; charset=utf-8

Content-Encoding: gzip

Expires: Mon, 25 May 2016 03:20:33 GMT

Last-Modified: Mon, 25 May 2016 03:20:03 GMT

Vary: Accept-Encoding

Server: Microsoft-IIS/7.0

X-AspNet-Version: 2.0.50727

X-Powered-By: ASP.NET

Date: Mon, 25 May 2016 03:20:02 GMT

Content-Length: 12173

## request 状态码

1xx：指示信息--表示请求已接收，继续处理

2xx：成功--表示请求已被成功接收、理解、接受

3xx：重定向--要完成请求必须进行更进一步的操作

4xx：客户端错误--请求有语法错误或请求无法实现

5xx：服务器端错误--服务器未能实现合法的请求